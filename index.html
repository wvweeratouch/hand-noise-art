<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Noise Art — Bri-yarni</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  html, body { width: 100%; height: 100%; overflow: hidden; background: #060610; }
  canvas { display: block; }
  #overlay {
    position: fixed; inset: 0;
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    background: rgba(6,6,16,0.92); color: #fff; font-family: 'Segoe UI', system-ui, sans-serif;
    z-index: 100; transition: opacity 0.8s;
  }
  #overlay.hidden { opacity: 0; pointer-events: none; }
  #overlay h1 { font-size: 2.2rem; font-weight: 300; margin-bottom: 0.4rem; letter-spacing: 0.08em; }
  #overlay p { font-size: 0.9rem; opacity: 0.6; margin-bottom: 1.8rem; }
  #startBtn {
    padding: 0.8rem 2.5rem; font-size: 1rem; border: 1px solid rgba(255,255,255,0.25);
    background: transparent; color: #fff; cursor: pointer; border-radius: 2rem;
    transition: all 0.3s;
  }
  #startBtn:hover { background: rgba(255,255,255,0.08); }
  #info { position: fixed; bottom: 0.8rem; left: 0.8rem; color: rgba(255,255,255,0.3); font: 0.7rem monospace; z-index: 50; pointer-events: none; }
</style>
</head>
<body>

<div id="overlay">
  <h1>Noise Art</h1>
  <p>sound + touch + flow — by Bri-yarni</p>
  <button id="startBtn">Begin</button>
</div>
<div id="info"></div>

<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.170.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.170.0/examples/jsm/"
  }
}
</script>

<script type="module">
import * as THREE from 'three';

// ═══════════════════════════════════════════════════════
// SIMPLEX NOISE 3D (compact JS — Stefan Gustavson)
// ═══════════════════════════════════════════════════════

const F3 = 1/3, G3 = 1/6;
const grad3 = [[1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0],[1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1],[0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]];
const perm = new Uint8Array(512);
{
  const p = new Uint8Array(256);
  for (let i = 0; i < 256; i++) p[i] = i;
  let s = 42;
  for (let i = 255; i > 0; i--) {
    s = (s * 16807) % 2147483647;
    const j = s % (i + 1);
    [p[i], p[j]] = [p[j], p[i]];
  }
  for (let i = 0; i < 512; i++) perm[i] = p[i & 255];
}

function noise3(x, y, z) {
  const s = (x + y + z) * F3;
  const i = Math.floor(x+s), j = Math.floor(y+s), k = Math.floor(z+s);
  const t = (i+j+k) * G3;
  const x0 = x-(i-t), y0 = y-(j-t), z0 = z-(k-t);
  let i1,j1,k1,i2,j2,k2;
  if (x0>=y0) {
    if (y0>=z0){i1=1;j1=0;k1=0;i2=1;j2=1;k2=0;}
    else if(x0>=z0){i1=1;j1=0;k1=0;i2=1;j2=0;k2=1;}
    else{i1=0;j1=0;k1=1;i2=1;j2=0;k2=1;}
  } else {
    if(y0<z0){i1=0;j1=0;k1=1;i2=0;j2=1;k2=1;}
    else if(x0<z0){i1=0;j1=1;k1=0;i2=0;j2=1;k2=1;}
    else{i1=0;j1=1;k1=0;i2=1;j2=1;k2=0;}
  }
  const x1=x0-i1+G3,y1=y0-j1+G3,z1=z0-k1+G3;
  const x2=x0-i2+2*G3,y2=y0-j2+2*G3,z2=z0-k2+2*G3;
  const x3=x0-0.5,y3=y0-0.5,z3=z0-0.5;
  const ii=i&255,jj=j&255,kk=k&255;
  let n=0;
  for (const [cx,cy,cz,gi] of [
    [x0,y0,z0,perm[ii+perm[jj+perm[kk]]]%12],
    [x1,y1,z1,perm[ii+i1+perm[jj+j1+perm[kk+k1]]]%12],
    [x2,y2,z2,perm[ii+i2+perm[jj+j2+perm[kk+k2]]]%12],
    [x3,y3,z3,perm[ii+1+perm[jj+1+perm[kk+1]]]%12],
  ]) {
    const t2=0.6-cx*cx-cy*cy-cz*cz;
    if(t2>0){const g=grad3[gi];n+=t2*t2*t2*t2*(g[0]*cx+g[1]*cy+g[2]*cz);}
  }
  return 32*n;
}

// ═══════════════════════════════════════════════════════
// AUDIO
// ═══════════════════════════════════════════════════════

let audioCtx, analyser, audioData;
let bass=0, mid=0, treble=0;
let bS=0, mS=0, tS=0; // smoothed

async function setupAudio() {
  try {
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    audioCtx = new AudioContext();
    const src = audioCtx.createMediaStreamSource(stream);
    analyser = audioCtx.createAnalyser();
    analyser.fftSize = 256;
    analyser.smoothingTimeConstant = 0.8;
    src.connect(analyser);
    audioData = new Uint8Array(analyser.frequencyBinCount);
    return true;
  } catch(e) { return false; }
}

function readAudio(dt) {
  if (!analyser) return;
  analyser.getByteFrequencyData(audioData);
  const bins = audioData.length;
  let b=0,m=0,t=0;
  const bE=Math.floor(bins*0.15), mE=Math.floor(bins*0.5);
  for (let i=0;i<bins;i++){
    const v=audioData[i]/255;
    if(i<bE)b+=v; else if(i<mE)m+=v; else t+=v;
  }
  bass=b/bE; mid=m/(mE-bE); treble=t/(bins-mE);
  const r=1-Math.exp(-8*dt);
  bS+=(bass-bS)*r; mS+=(mid-mS)*r; tS+=(treble-tS)*r;
}

// ═══════════════════════════════════════════════════════
// MOUSE
// ═══════════════════════════════════════════════════════

const mouse = { x: 0, y: 0, down: false };
window.addEventListener('pointermove', e => {
  mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
});
window.addEventListener('pointerdown', () => mouse.down = true);
window.addEventListener('pointerup', () => mouse.down = false);

// ═══════════════════════════════════════════════════════
// THREE.JS SCENE
// ═══════════════════════════════════════════════════════

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setPixelRatio(Math.min(devicePixelRatio, 1.5));
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.0;
document.body.prepend(renderer.domElement);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x060610);
scene.fog = new THREE.FogExp2(0x060610, 0.12);

const camera = new THREE.PerspectiveCamera(55, window.innerWidth/window.innerHeight, 0.1, 50);
camera.position.z = 6;

window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

// ═══════════════════════════════════════════════════════
// LIGHTS (audio-reactive colors)
// ═══════════════════════════════════════════════════════

const ambientLight = new THREE.AmbientLight(0x111122, 0.3);
scene.add(ambientLight);

// Three colored lights orbiting the scene
const lights = [];
const lightColors = [
  new THREE.Color(0x4466ff), // blue (bass)
  new THREE.Color(0xaa44ff), // purple (mid)
  new THREE.Color(0xff4488), // pink (treble)
];

for (let i = 0; i < 3; i++) {
  const light = new THREE.PointLight(lightColors[i], 2, 12);
  scene.add(light);
  lights.push(light);
}

// ═══════════════════════════════════════════════════════
// CENTRAL MESH — glass icosphere (built-in material)
// ═══════════════════════════════════════════════════════

const icoGeo = new THREE.IcosahedronGeometry(1.2, 2); // 162 vertices — light
const icoBasePositions = icoGeo.getAttribute('position').array.slice(); // save original

const icoMat = new THREE.MeshPhysicalMaterial({
  color: 0x8888ff,
  metalness: 0.1,
  roughness: 0.15,
  transmission: 0.85,
  thickness: 0.5,
  ior: 1.5,
  transparent: true,
  opacity: 0.9,
  side: THREE.DoubleSide,
});

const icoMesh = new THREE.Mesh(icoGeo, icoMat);
scene.add(icoMesh);

// Wireframe overlay for visual interest
const wireGeo = new THREE.IcosahedronGeometry(1.22, 1);
const wireMat = new THREE.MeshBasicMaterial({
  color: 0x6644cc,
  wireframe: true,
  transparent: true,
  opacity: 0.15,
});
const wireMesh = new THREE.Mesh(wireGeo, wireMat);
scene.add(wireMesh);

// ═══════════════════════════════════════════════════════
// PARTICLES (PointsMaterial — no custom shader)
// ═══════════════════════════════════════════════════════

const PCOUNT = 2000;
const pGeo = new THREE.BufferGeometry();
const pPos = new Float32Array(PCOUNT * 3);
const pCol = new Float32Array(PCOUNT * 3);
const pBase = []; // base orbit parameters

for (let i = 0; i < PCOUNT; i++) {
  // Spherical base distribution
  const theta = Math.random() * Math.PI * 2;
  const phi = Math.acos(Math.random() * 2 - 1);
  const r = 1.8 + Math.random() * 2.5;
  pPos[i*3]   = r * Math.sin(phi) * Math.cos(theta);
  pPos[i*3+1] = r * Math.sin(phi) * Math.sin(theta);
  pPos[i*3+2] = r * Math.cos(phi);
  // Initial colors (will be updated)
  pCol[i*3] = 0.3; pCol[i*3+1] = 0.3; pCol[i*3+2] = 0.8;
  // Store base orbit params
  pBase.push({ theta, phi, r, speed: 0.2 + Math.random() * 0.4 });
}

pGeo.setAttribute('position', new THREE.BufferAttribute(pPos, 3));
pGeo.setAttribute('color', new THREE.BufferAttribute(pCol, 3));

const pMat = new THREE.PointsMaterial({
  size: 0.04,
  vertexColors: true,
  transparent: true,
  opacity: 0.6,
  sizeAttenuation: true,
  blending: THREE.AdditiveBlending,
  depthWrite: false,
});

const points = new THREE.Points(pGeo, pMat);
scene.add(points);

// ═══════════════════════════════════════════════════════
// ANIMATION
// ═══════════════════════════════════════════════════════

const clock = new THREE.Clock();
let time = 0;
let hue = 0.6;

function animate() {
  requestAnimationFrame(animate);
  const dt = Math.min(clock.getDelta(), 0.05);
  time += dt;

  readAudio(dt);

  // ── Hue drift ──
  hue += dt * (0.015 + mS * 0.02);

  // ── Camera follows mouse gently ──
  const targetCamX = mouse.x * 1.5;
  const targetCamY = mouse.y * 1.0;
  camera.position.x += (targetCamX - camera.position.x) * dt * 3;
  camera.position.y += (targetCamY - camera.position.y) * dt * 3;
  camera.lookAt(0, 0, 0);

  // ── Lights orbit + audio-reactive color/intensity ──
  for (let i = 0; i < 3; i++) {
    const angle = time * (0.3 + i * 0.15) + i * Math.PI * 2 / 3;
    const r = 3 + Math.sin(time * 0.5 + i) * 0.5;
    lights[i].position.set(
      Math.cos(angle) * r,
      Math.sin(time * 0.4 + i * 2) * 1.5,
      Math.sin(angle) * r
    );
    // Audio reactive intensity
    const audioVal = [bS, mS, tS][i];
    lights[i].intensity = 1.5 + audioVal * 4;

    // Shift light colors with hue
    const h = (hue + i * 0.25) % 1;
    const c = new THREE.Color();
    c.setHSL(h, 0.7, 0.4 + audioVal * 0.2);
    lights[i].color.copy(c);
  }

  // ── Mesh: CPU noise displacement ──
  const posAttr = icoGeo.getAttribute('position');
  const arr = posAttr.array;
  const noiseScale = 1.5 + tS * 2;
  const noiseAmp = 0.1 + bS * 0.4;

  for (let i = 0; i < arr.length; i += 3) {
    const bx = icoBasePositions[i];
    const by = icoBasePositions[i+1];
    const bz = icoBasePositions[i+2];

    // Displacement along normal (base position IS the normal for unit sphere)
    const len = Math.sqrt(bx*bx + by*by + bz*bz);
    const nx = bx/len, ny = by/len, nz = bz/len;

    const disp = noise3(bx * noiseScale, by * noiseScale, bz * noiseScale + time * 0.5) * noiseAmp;

    arr[i]   = bx + nx * disp;
    arr[i+1] = by + ny * disp;
    arr[i+2] = bz + nz * disp;
  }
  posAttr.needsUpdate = true;
  icoGeo.computeVertexNormals();

  // Mesh rotation — gentle + mouse influence
  icoMesh.rotation.y += dt * 0.15;
  icoMesh.rotation.x += dt * 0.08;
  if (mouse.down) {
    icoMesh.rotation.y += mouse.x * dt * 2;
    icoMesh.rotation.x += mouse.y * dt * 2;
  }

  // Mesh scale pulse with bass
  const targetScale = 1.0 + bS * 0.3;
  icoMesh.scale.lerp(new THREE.Vector3(targetScale, targetScale, targetScale), dt * 6);

  // Wireframe follows
  wireMesh.rotation.copy(icoMesh.rotation);
  wireMesh.scale.copy(icoMesh.scale);
  wireMat.opacity = 0.1 + tS * 0.15;

  // Mesh color shifts with audio
  const meshH = (hue + 0.6) % 1;
  icoMat.color.setHSL(meshH, 0.5 + mS * 0.3, 0.5 + bS * 0.15);

  // ── Particles: noise-driven orbits ──
  const pArr = pGeo.getAttribute('position').array;
  const cArr = pGeo.getAttribute('color').array;

  for (let i = 0; i < PCOUNT; i++) {
    const b = pBase[i];
    const t2 = time * b.speed;

    // Noise-perturbed orbit
    const theta = b.theta + t2 + noise3(i * 0.1, time * 0.2, 0) * 0.5;
    const phi = b.phi + noise3(0, i * 0.1, time * 0.15) * 0.3;
    const r = b.r + noise3(i * 0.05, 0, time * 0.3) * 0.5 + bS * 0.8;

    pArr[i*3]   = r * Math.sin(phi) * Math.cos(theta);
    pArr[i*3+1] = r * Math.sin(phi) * Math.sin(theta);
    pArr[i*3+2] = r * Math.cos(phi);

    // Mouse attraction when pressed
    if (mouse.down) {
      const mx = mouse.x * 3, my = mouse.y * 3;
      const dx = mx - pArr[i*3], dy = my - pArr[i*3+1];
      const dist = Math.sqrt(dx*dx + dy*dy);
      if (dist < 3) {
        const pull = (1 - dist/3) * 0.3;
        pArr[i*3]   += dx * pull;
        pArr[i*3+1] += dy * pull;
      }
    }

    // Color — hue varies by position + audio
    const pH = (hue + i / PCOUNT * 0.4 + mS * 0.1) % 1;
    const pSat = 0.6 + tS * 0.3;
    const pLit = 0.3 + bS * 0.3;
    // HSL to RGB (inline)
    const c = new THREE.Color();
    c.setHSL(pH, pSat, pLit);
    cArr[i*3] = c.r; cArr[i*3+1] = c.g; cArr[i*3+2] = c.b;
  }

  pGeo.getAttribute('position').needsUpdate = true;
  pGeo.getAttribute('color').needsUpdate = true;

  // Particle size pulses with bass
  pMat.size = 0.03 + bS * 0.06;
  pMat.opacity = 0.4 + bS * 0.3;

  // ── Fog density reacts to audio ──
  scene.fog.density = 0.1 + bS * 0.05;

  // ── Render ──
  renderer.render(scene, camera);
}

// ═══════════════════════════════════════════════════════
// START
// ═══════════════════════════════════════════════════════

const info = document.getElementById('info');

document.getElementById('startBtn').addEventListener('click', async () => {
  const overlay = document.getElementById('overlay');
  overlay.classList.add('hidden');
  setTimeout(() => overlay.style.display = 'none', 800);

  const micOk = await setupAudio();
  info.textContent = micOk
    ? 'mic on — make noise or play music | drag to interact'
    : 'mic off — drag to interact';

  clock.start();
  animate();
});
</script>
</body>
</html>
